import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { NextRequest, NextResponse } from 'next/server'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY!

async function getSupabaseWithAuth() {
    const cookieStore = await cookies()

    return createServerClient(supabaseUrl, supabaseAnonKey, {
        cookies: {
            getAll() {
                return cookieStore.getAll()
            },
            setAll(cookiesToSet) {
                cookiesToSet.forEach(({ name, value, options }) =>
                    cookieStore.set(name, value, options)
                )
            },
        },
    })
}

export async function POST(request: NextRequest) {
    try {
        const supabase = await getSupabaseWithAuth()
        const { data: { user }, error: authError } = await supabase.auth.getUser()

        if (authError || !user) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
        }

        const body = await request.json()
        const { photos } = body // Expecting array of { storage_path, id }

        if (!photos || !Array.isArray(photos) || photos.length === 0) {
            return NextResponse.json({ success: true, count: 0 }) // Nothing to delete
        }

        // 1. Delete from Storage
        // Extract paths. If storage_path is missing, try to infer from url or skip
        const pathsToDelete = photos
            .map(p => p.storage_path)
            .filter(Boolean) as string[]

        if (pathsToDelete.length > 0) {
            const { error: storageError } = await supabase.storage
                .from('photos')
                .remove(pathsToDelete)

            if (storageError) {
                console.error('Storage delete error:', storageError)
                // Continue to DB delete even if storage fails partial
            }
        }

        // 2. Delete from DB (photos table) using IDs?
        // Wait, not all photos might have DB entries if valid `id` isn't provided or matches.
        // But we should try to clean up the DB `photos` table regardless.
        // Assuming we pass objects that have the DB `id` or we filter by storage path?
        // If the client passes the `Photo` object from `types.ts`, it has `id`.
        // BUT, the `id` in `types.ts` might be a UUID from DB OR generated by `crypto.randomUUID()`?
        // Actually upload returns `photoData` which is the DB row. So `photo.id` should be the DB id.

        // Let's delete by storage_path as it's more reliable if we have it, OR by ID.
        // Let's rely on storage_path for DB lookup ?? No, ID is better.
        // Actually, let's try to delete by ID if present.

        // However, `allPhotos` in state might mix DB photos and others.
        // The safest common denominator is `storage_path` if available.

        // Let's delete from DB where storage_path is IN our list
        if (pathsToDelete.length > 0) {
            const { error: dbError } = await supabase
                .from('photos')
                .delete()
                .in('storage_path', pathsToDelete)

            if (dbError) console.error('DB delete error', dbError)
        }

        return NextResponse.json({ success: true, count: pathsToDelete.length })

    } catch (error) {
        console.error('Batch delete error:', error)
        return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
    }
}
